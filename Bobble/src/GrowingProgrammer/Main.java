package GrowingProgrammer;

public class Main {

    public static void main(String[] args) {
	/*
	要求:把下面五个无序的数，使用冒泡排序法排成一个从小到大的有序数列，并打印排序过程，如果是已经拍好顺序的数字，可以中断程序
	24，69， 80， 57， 12

	思路分析：
	1. 定义数组arr = {24，69， 80， 57， 12}
	2. 第一个数和第二个数比较，如果比较大的的就交换位置，如果变化不大的话就保留在原地
	3. 现在第二个数字arr[1]已经是比较大的了，这个比较大的再和下一个数字进行比较，如果还是比较大舅换到下一个位置
        以此类推，直到到最后一个数字进行比较，把这一轮的比较全部列下来，如下：
    第一轮（4次）4-0
        a[0] a[1]
        a[1] a[2]
        a[2] a[3]
        a[3] a[4]
        五个数字要比较四次才可以把最大的数字推到最右边
        把这一轮的代码写出来，使用for循环，初始值设置为0（因为数字下标是从0开始，初始值为0很容易用来表示数字），筛选条件时<4,i++依次递增
	    把循环里的代表数字下标的地方的用替代一下

    4. 这才把最大的数推到了右边，接下来还要来一轮，但这次不同的是，不用和最后那个数字进行比较，只要比较三次即可，后面每轮还会减少一次
    第二轮（3次）4-1
        a[0] a[1]
        a[1] a[2]
        a[2] a[3]
    第三轮（2次）4-2
        a[0] a[1]
        a[1] a[2]
    第四轮（1次）4-1
        a[0] a[1]

        也就是说下面的那个推送最大值的循环是要进行四次的
        同时下面这个循环每次循环次数是递减的

        上面这两句话，我们一点一点来实现，把下面的循环实现4次，再在外面加上一个for循环
        （4次和内循环的第一轮的次数是一样的，但还是不能直接把计数放在同一个循环里，是因为内部循环会每次减少一个）
        接着我们要实现，内部循环每次递减，这个地方很关键，在我写的下面的数字中i和j起始值都是固定的，开始循环以后不会再重新赋值了
        但是筛选条件时每次都要过一遍的
        只要把筛选条件做成活的就可以了，可以用外层循环的计数来做，刚好筛选条件可以做成是i-j的形式

    5. 把i和j的数字换一下

    6. 先死后活，把4给换一下

    7. 加一个功能，如果第一遍什么都没有换，怎么处理
    其实就是跑完第一轮数字没有交换位置。这就需要内部循环跑完一轮，if内部的语句没有运行过，判断方法是在if内部植入一个计数框，如果运行过就会增加，后面就可以通过判断这个计数的大小来设置相应的输出


	 */

        int[] arr = {24, 69, 80, 57, 12};
        int count = 0;
        for(int i = 0; i < arr.length - 1; i ++) {
            for(int j = 0; j < arr.length - 1 - i; j++) {
                int temp = 0;
                if(arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    count++;
                }
            }
            System.out.println("");
            if (count > 0) {
                System.out.println("Round No." + (i + 1) + " is like below:");
                for(int c = 0; c < 5; c++) {
                    System.out.print(arr[c] + " ");
                }
            } else {
                System.out.println("The original array is already in the right order.");
                break;
            }

        }


    }
}
/*
另外一个推导方法：
第一轮：
1. （24 69） 80 57 12
2. 24 （69 80） 57 12
3. 24 69 （57 80） 12
4. 24 69 57 （12 80）

第二轮：
1. （24 69） 57 12 80
2. 24 （57 69） 12 80
3. 24 57 （12 69）80

第三轮：
1. （24 57）12 69 80
2. 24 （12 57）69 80

第四轮：
1. （12 24）57 69 80

先写第一轮
然后再写多轮

我会更喜欢自己的推导方式，对我来说更容易做出来


 */
